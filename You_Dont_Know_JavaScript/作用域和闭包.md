## 词法作用域
作用域
- 词法作用域
- 动态作用域

全局变量会自动成为全局对象( 比如浏览器中的window对象 ) 的属性，因此可以不直接通过全局对象的词法名称，而是间接地通过对全局对象属性的引用来对其进行访问.
```javascript
window.a
```

无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都**只由函数被声明时所处的位置**决定。

词法作用域查找只会查找一级标识符，比如 a、b 和 c。如果代码中引用了 foo.bar.baz，词法作用域查找只会试图查找 foo 标识符，找到这个变量后，对象属性访问规则会分别接管对 bar 和 baz 属性的访问。

### 欺骗词法

1. eval 函数 
2. with 

- eval 

```javascript 
function foo(str , a) {
    eval(str) // 欺骗
    console.log(a,b);
}

var b = 1 ;
foo('var b = 2' , 4) // 4 2
foo('', 4) // 4 1  

```
在执行 `eval(..)` 之后的代码时，引擎并不“知道”或“在意”前面的代码是以**动态形式插入进来**，并对词法作用域的环境进行修改的。引擎只会如往常地进行词法作用域查找。

也就是说，`eval(..)` 可以在运行期修改书写期的词法作用域

>在严格模式的程序中，eval(..) 在运行时有其自己的词法作用域，意味着其中的声明无法修改所在的作用域。

```javascript
function foo(str){
    "use strict"
    eval(str)
    console.log(a) // ReferenceError : a is not defined

}

foo('var a = 2 ')
```

> 负作用

这两个机制的副作用是引擎无法在编译时对作用域查找进行优化，因为引擎只能谨慎地认为这样的优化是无效的。使用这其中任何一个机制都将导致代码运行变慢。不要使用它们。




## 函数作用域和块作用域

### 函数中的作用域
含义：
函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用（事实上在嵌套的作用域中也可以使用）。这种设计方案是非常有用的，能充分利用JavaScript 变量可以根据需要改变值类型的“动态”特性。

函数作用域的作用：
- 隐藏内部实现

- 规避冲突

>隐藏内部实现
```javascript
 function doSth (a) {      
    b = a + doSthElse(a + 5) 
    console.log(b * 5);       
}

function doSthElse (a) {
    return a + 1
}

var b  

doSth(3) // 60 

另一种实现方法
function doSth(a) {
    function doSthElse(a) {
        return a + 1
    }
    var b
    b = a + doSthElse(a + 5)
    console.log(b * 5);
}
doSth(3) // 60
```
第二种写法中，`b` 和 `doSthElse(..)` 都无法从外部被访问，只能被`doSth`所控制，更好地实现了私有化


>规避冲突

#### 函数声明 和 函数表达式

包装函数的声明以 (function... 而不仅是以 function... 开始。尽管看上去这并不是一个很显眼的细节，但实际上却是非常重要的区别。函数会被当作函数表达式而不是一个标准的函数声明来处理。

区分函数声明和表达式最简单的方法是看 `function` 关键字出现在声明中的位置（不仅仅是一行代码，而是整个声明中的位置）。如果 `function` 是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。

函数声明和函数表达式之间最重要的区别是它们的名称标识符将会绑定在何处。

比较一下前面两个代码片段。第一个片段中 foo 被绑定在所在作用域中，可以直接通过foo() 来调用它。第二个片段中foo 被绑定在函数表达式自身的函数中而不是所在作用域中。

换句话说，`(function foo(){ .. })` 作为函数表达式意味着 foo 只能在 `..` 所代表的位置中被访问，外部作用域则不行。foo 变量名被隐藏在自身中意味着不会非必要地污染外部作用域。

#### 匿名函数 和 具名函数
匿名函数
```javascript
setTimeout(function(){
    console.log('I waited 1 second')
},1000)
```


匿名函数的几个缺点

1. 匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。
2. 如果没有函数名，当函数需要引用自身时只能使用已经过期的 arguments.callee 引用，比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑自身。
3. 匿名函数省略了对于代码可读性 / 可理解性很重要的函数名。一个描述性的名称可以让代码不言自明。

行内函数表达式非常强大且有用——匿名和具名之间的区别并不会对这点有任何影响。给函数表达式指定一个函数名可以有效解决以上问题。始终给函数表达式命名是一个最佳实践：

```javascript
setTimeout(function timeoutHandler(){
    console.log('I waited 1 second')
},1000)

```

#### 立即执行函数表达式 （IIFE）
- IIFE的两种形式
```javascript
// 方式 1 



// 方式 2 
```
- IIFE的常见用法
    - 把IIFE当作函数调用并传递参数进去
    - 解决`undefined`标识符的默认值被错误覆盖导致的异常
    
### 块作用域

```javascript
 for(var i=0; i<10 ; i++) {
    console.log( i )
 }
```
上面这段代码中, 变量 i 实际上会被绑定在 外部作用域中

#### 块级作用域的列子

>try / catch

>let / const

>块作用域的作用

- 垃圾回收
```javascript


```

- `let`循环



## 提升

**先声明再赋值**

```javascript
a = 2;
var a
console.log(a); // 2

console.log(b); //undefined
var b = 2 

```

- 函数声明会被提升，但是函数表达式不会被提升

### 函数优先

函数声明和变量声明都会被提升，但是**函数提升会优先**于变量提升

```javascript
foo() // 1 

var foo

function foo(){
    console.log( 1 )
}

foo = function() {
    console.log( 2 )
}

```
这个代码片段会被引擎理解为下面的代码
```javascript
function foo(){
    console.log( 1 )
}

foo() // 1 

foo = function() {
    console.log( 2 )
}
```


## 作用域闭包

定义：当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。

